В декабре 2022 - марте 2023 я проходил практику на позиции backend-разработчика. В нашем сервисе мы использовали Hapi.js и TypeORM.
По ходу работы самая большая проблема для меня была не в том как реализовать ту или иную возможность сервиса, а в том как написать такой код который будет легко пониматься, поддерживаться и расширяться другими разработчиками. В итоге, несмотря на приложенные усилия, я был немного неудовлетворен своей работой.

Как выглядело наше приложение с точки зрения архитектуры:
- есть главный модуль приложения, загружающий все плагины;
- есть плагины для каждой бизнес-сущности (например, для пользователя). Каждый такой плагин импортировал и регистрировал маршруты, маршруты импортировали контроллеры, контроллеры импортировали сервисы, сервисы обращались к методам классов, расширяющих BaseEntity из TypeORM (для обращения к БД мы использовали паттерн Active Record)
- если одному плагину нужно было обратиться к другой бизнес-сущности, то импортировался класс Entity нужной сущности.

В результате все модули приложения были достаточно тесно связаны друг с другом, и при реализации каждой следующей новой фичи нам приходилось изменять всё больше модулей. 

После практики я прошел курсы по NodeJS от [PurpleSchool](https://purpleschool.ru/) (автор - [Антон Ларичев](https://github.com/AlariCode)) и в качестве дополнительной самостоятельной работы попытался применить полученные знания на том же стеке который был у меня на практике.

Мне кажется что у меня получилось решить некоторые проблемы, с которыми я не разобрался во время практики. Основные преимущества реализованного решения:
- приложение делится на модули, соответствующие сущностям бизнес-домена. Модули можно максимально изолировать друг от друга, в том числе каждый модуль может самостоятельно загружать необходимые именно ему плагины Hapi.
- каждый модуль делится на части, работающие с конкретными слоями приложения: 
  - контроллеры, маршруты, схемы валидации - слой инфраструктуры
  - сервис - слой бизнес-логики
  - репозиторий - слой постоянного хранения данных.
- зависимости модулей разрешаются с помощью инъекций, реализуя принцип инверсии зависимостей. Реализации зависимых классов импортируют интерфейсы зависимостей, а не их реализации.
